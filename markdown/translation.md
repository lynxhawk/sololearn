## 开发方法论与哲学
尽管我们大多数人都在非开源的项目上工作，但我们都可以从以下开源最佳实践中受益，其中许多实践仍然适用于闭源项目开发。 假装我们所有的代码将是更好的配置和秘密管理，更好的文档，更好的接口和更可维护的代码库的开源结果。

在本章中，我们将探讨开源规则，并探讨我们可以采用的方法和一套称为“十二因子应用程序”[1]的健全性原则 - 通常是为后端开发而设计 - 现代 JavaScript应用程序开发，前端和后端等。
### 6.1安全配置管理
当谈到闭源项目中的配置机密时，例如API密钥或HTTPS会话解密密钥，对它们进行硬编码并不罕见。相反，在开源项目中，这些通常是通过环境变量或加密配置文件获得的，这些文件未与我们的代码库一起提交给版本控制系统。

对于开源项目，这允许开发人员共享其绝大多数应用程序，而不会影响其生产系统的安全性。虽然这可能不是闭源环境中的直接关注点，但我们需要考虑的是，一旦秘密被提交到版本控制，它就会被刻入我们的版本历史中，除非我们强制重写该历史记录，擦除存在的秘密。即使这样，也无法保证恶意行为者在从历史记录中清除之前的某个时刻已经获得了这些机密的访问权限，因此更好地解决这个问题就是轮换可能受到损害的秘密，通过旧秘密撤销访问权限并开始使用新的，不妥协的秘密。

虽然有效，但是当我们掌握了几个秘密时，这种方法可能非常耗时，而且当我们的应用程序足够大时，即使暴露很短的时间，泄露的秘密也会带来很大的风险。因此，最好在默认情况下仔细考虑秘密，并避免在项目生命周期的后期出现问题。

我们可以做的绝对最少的是给每个秘密一个唯一的名称，并将它们放在一个JSON文件中。任何敏感信息或可配置值都可能属于机密，这可能包括用于签署证书的私有签名密钥到端口号或数据库连接字符串。
```
{
  "PORT": 3000,
  "MONGO_URI": "mongodb://localhost/mjavascript",
  "SESSION_SECRET": "ditch-foot-husband-conqueror"
}
```
我们将所有敏感信息集中在单个文件中，然后可以从版本控制中排除，而不是将这些变量硬编码到任何使用它们的地方，或者甚至将它们放在模块开头的常量中。除了帮助我们分享模块之间的秘密，使更新更容易，这种方法鼓励我们隔离我们以前不会认为敏感的信息，例如用于加盐密码的工作因素。

沿着这条道路前进的另一个好处是，鉴于我们在中央商店中有所有环境配置，我们可以将我们的应用程序指向另一个秘密商店，具体取决于我们是否为生产，分阶段或其中一个提供应用程序开发人员使用的开发环境。

在分享秘密时，鉴于我们故意将它们从源版本控制中排除，我们可以采取许多方法，例如使用环境变量，将它们存储在Amazon S3存储桶中保存的JSON文件中，或者使用专用的加密存储库我们的申请秘密。

使用通常所说的“dot env”文件是在Node.js应用程序中安全地管理机密的有效方法，并且有一个名为nconf的模块可以帮助我们设置它们。这些文件通常包含两种类型的数据：不能在执行环境之外共享的秘密，以及应该可编辑且我们不想硬编码的配置值。

在现实环境中实现这一目标的一种具体而有效的方法是使用几个“dot env”文件，每个文件都有明确定义的目的。按优先顺序排列：
- `.env.defaults.json`可用于定义不必跨环境覆盖的默认值，例如应用程序侦听端口，NODE_ENV变量以及您不希望硬编码到应用程序代码中的可配置选项。 这些默认设置应该是安全的，以检查源代码管理
- `.env.production.json`,`.env.staging.json`,和其他可用于特定于环境的设置，例如数据库的各种生产连接字符串，cookie编码机密，API密钥等等
- `.env.json`可能是您的本地特定于计算机的设置，对于不应与其他团队成员共享的机密或配置更改非常有用
此外，您还可以通过环境变量接受对环境设置的简单修改，例如在执行`PORT = 3000 node app`时，这在开发期间很方便。

我们可以使用`nconf` npm包来轻松处理和合并所有这些应用程序设置源。

下面的代码展示了如何配置`nconf`来执行我们刚刚描述的操作：我们导入`nconf`包，并将配置源从最高优先级声明为最低优先级，而`nconf`将执行合并（更高优先级设置将始终采用优先级）。 然后我们设置实际的`NODE_ENV`环境变量，因为库依赖于此属性来决定是否检测或优化其输出。
```
// env
import nconf from 'nconf'

nconf.env()
nconf.file('environment', `.env.${ nodeEnv() }.json`)
nconf.file('machine', '.env.json')
nconf.file('defaults', '.env.defaults.json')

process.env.NODE_ENV = nodeEnv() // consistency

function nodeEnv() {
  return accessor('NODE_ENV')
}

function accessor(key) {
  return nconf.get(key)
}

export default accessor
```
该模块还公开了一个接口，通过该接口，我们可以通过调用`env（'PORT'）`之类的函数调用来使用这些应用程序设置。 每当我们需要访问其中一个配置设置时，我们就可以导入`env.js`并询问相关设置的计算值，`nconf`负责确定哪些设置优先于什么，以及值应该是什么 适合当前的环境。
```
import env from './env'

const port = env('PORT')
```
假设我们有一个如下所示的`.env.defaults.json`，我们可以在启动我们的暂存，测试或生产应用程序时传入`NODE_ENV`标志，并获得适当的环境设置，帮助我们简化加载环境的过程。
```
{
  "NODE_ENV": "development"
}
```
我们通常发现自己需要在客户端复制这种逻辑。 当然，我们不能在客户端共享服务器端的秘密，因为这会泄漏我们的秘密给任何窥探浏览器中的JavaScript文件的人。 不过，我们可能希望能够访问一些环境设置，例如`NODE_ENV`，我们的应用程序的域或端口，Google Analytics跟踪ID以及类似的安全广告配置详细信息。

说到浏览器，我们可以使用完全相同的文件和环境变量，但是包含一个专用的浏览器特定对象字段，如下所示：
```
{
  "NODE_ENV": "development",
  "BROWSER_ENV": {
    "MIXPANEL_API_KEY": "some-api-key",
    "GOOGLE_MAPS_API_KEY": "another-api-key"
  }
}
```
然后，我们可以编写如下的小脚本来打印所有这些设置。
```
// print-browser-env
import env from './env'
const browserEnv = env('BROWSER_ENV')
const prettyJson = JSON.stringify(browserEnv, null, 2)
console.log(prettyJson)
```
当然，我们不希望将服务器端设置与浏览器设置混合，因为任何拥有用户代理，访问我们网站的能力以及基本编程技能的人都可以访问浏览器设置，这意味着我们最好不要捆绑 我们的客户端应用程序的高度敏感的秘密。 要解决此问题，我们可以使用构建步骤将适当环境的设置打印到`.env.browser.json`文件，然后仅在客户端使用该文件。

我们可以将这个封装结合到我们的构建过程中，添加以下命令行调用。
```
node print-browser-env > browser/.env.browser.json
```
请注意，为了使此模式正常工作，我们需要知道在编译浏览器点env文件时我们正在构建的环境，因为传入不同的`NODE_ENV`环境变量会产生不同的结果，具体取决于我们的目标环境。

通过以这种方式编译客户端配置设置，我们避免将服务器端配置机密泄漏到客户端。

此外，我们应该从客户端的服务器端复制`env`文件，以便在线路的两端以相同的方式使用应用程序设置。
```
// browser/env
import env from './env.browser.json'

export default function accessor(key) {
  if (typeof key !== 'string') {
    return env
  }
  return key in env ? env[key] : null
}
```
存储我们的应用程序设置还有许多其他方式，每种方式都有自己相关的优缺点。 不过，我们刚刚讨论过的方法相对容易实现，并且足够强大，可以开始使用。 作为升级，您可能希望使用AWS Secrets Manager。 这样，你就有一个秘密来处理团队成员的环境，而不是每一个秘密。

秘密服务还负责加密，安全存储，秘密轮换（在数据泄露的情况下有用）以及其他高级功能。

###6.2 显式依赖管理
我们有时会想要将依赖项检查到源代码控制中的原因是，我们在每个环境中每次都在依赖关系树中获得完全相同的版本。

在我们的存储库中包含依赖树是不切实际的，但是，鉴于它们通常在数百兆字节中，并且经常包括基于目标环境和操作系统构建的编译资产[2]，这意味着构建过程本身就是环境 -  依赖的，因此不适用于可能与平台无关的代码库。

在开发过程中，我们希望确保对依赖项进行非破坏性升级，这可以帮助我们解决上游错误，加强对安全漏洞的控制，并利用新功能或改进。 但是，对于部署，我们需要可重现的构建，其中安装我们的依赖项每次都会产生相同的结果。

解决方案是包含一个依赖项清单，指示我们要安装的依赖关系树中库的确切版本。这可以通过npm（从版本5开始）及其`package-lock.json`清单，以及通过Facebook的Yarn包管理器及其`yarn.lock`清单来完成，我们应该将其发布到我们的版本化存储库。

在不同环境中使用这些清单可确保我们获得可重复安装的依赖项，这意味着每个使用代码库的人员以及托管环境都会处理相同的软件包版本，无论是在顶级（直接依赖）还是嵌套深度（依赖关系）依赖关系 - 依赖关系）。

我们的应用程序中的每个依赖项都应该在我们的清单中显式声明，尽可能少地依赖全局安装的包或全局变量 - 理想情况下根本不依赖。隐式依赖涉及跨环境的其他步骤，开发人员和部署流都必须采取措施来确保安装这些额外的依赖关系，超出简单的`npm install`步骤可以实现的范围。以下是`package-lock.json`文件的示例：
```
{
  "name": "A",
  "version": "0.1.0",
  // metadata…
  "dependencies": {
    "B": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/B/-/B-0.0.1.tgz",
      "integrity": "sha512-DeAdb33F+"
      "dependencies": {
        "C": {
          "version": "git://github.com/org/C.git#5c380ae319fc4efe9e7f2d9c78b0faa588fd99b4"
        }
      }
    }
  }
}
```
使用包锁文件中的信息，包含我们依赖的每个包及其所有依赖项的详细信息，包管理器可以采取步骤每次安装相同的位，保留我们快速迭代和安装包更新的能力， 同时保持我们的代码安全。

始终安装相同版本的依赖项 - 以及依赖项依赖项的相同版本 - 使我们更接近于使开发环境与我们在生产中所做的一致。 这增加了我们可以迅速重现在我们的本地环境中生产中发生的错误的可能性，同时降低了在开发期间工作中出现的错误的可能性。

### 6.3 黑盒接口
在与上一节类似的说明中，我们应该对待自己的组件与处理第三方库和模块的方式没有什么不同。当然，我们可以更快地对我们自己的代码进行更改，而不是在第三方代码中实现更改 - 如果可能的话，在某些情况下。但是，当我们将所有组件和接口（包括我们自己的HTTP API）视为对我们来说是外来的时，我们可以专注于对接口进行消费和测试，同时忽略底层实现。

改进接口的一种方法是编写有关接口接口所期望的输入的详细文档，以及它如何影响它在每种情况下提供的输出。编写文档的过程可以揭示界面设计的局限性，并且我们可能会决定更改它。消费者喜欢良好的文档，因为它意味着对实现（或其实现者）不那么笨拙，理解界面是如何被消费的，以及它是否能够实现他们所需要的。

避免区别有助于我们编写单元测试，我们可以模拟未经测试的依赖项，无论它们是由内部开发还是由第三方开发。在编写测试时，我们总是认为第三方模块通常经过充分测试，因此在我们的测试用例中包含它们不是我们的责任。同样的想法应该适用于恰好是我们当前正在编写测试模块的依赖关系的第一方模块。

同样的推理可以应用于安全问题，例如输入清理。无论我们正在开发什么样的应用程序，我们都不能信任用户输入，除非它被消毒。恶意行为者可能会倾向于接管我们的服务器，客户的数据或以其他方式将内容注入我们的网页。这些用户可能是客户甚至是员工，因此在进行输入清理时，我们不应根据具体情况对其进行区别对待。

把自己置于消费者的角度，是保护我们免受半生不熟的界面影响的最佳工具。当 - 作为思考练习 - 你停下来思考你想要如何使用界面，以及你可能需要使用它的不同方式时，你最终会得到一个更好的界面。这并不是说我们希望让消费者能够做到所有事情，但我们希望在消费界面变得尽可能简单并且感觉不像是一件苦差事的情况下提供可靠性。如果消费者在使用界面后立即需要包含长块业务逻辑，我们需要停下来问：业务逻辑是否属于界面而不是在其门口？

### 6.4 构建，发布，运行
构建过程有几个不同的方面。在最高级别，存在共享逻辑，我们在其中安装和编译资产，以便我们的运行时应用程序可以使用它们。这可能意味着安装系统或应用程序依赖项，将文件复制到不同的目录，将文件编译为不同的语言或将它们捆绑在一起，以及应用程序可能具有的众多其他要求。

在跨开发，登台和生产环境成功管理应用程序时，明确定义和描述构建过程是关键。这些常见环境中的每一个以及您可能遇到的其他环境都用于特定目的，并且可以从实现该目的的角度出发。

对于开发，我们专注于增强的调试功能，使用库的开发版本，源映射和详细的日志记录级别;自定义覆盖行为的方式，以便我们可以轻松模仿生产环境的样子，并且在可能的情况下，我们还会投入一个实时调试服务器，负责在代码更改时重新启动应用程序，应用CSS更改而不刷新页面，等等。

在暂存中，我们需要一个与生产非常相似的环境，因此我们将避免大多数调试功能，但我们可能仍希望源映射和详细日志记录能够轻松跟踪错误。我们的暂存环境的主要目标通常是在生产推动之前消除尽可能多的错误，因此这些环境在调试可用性和生产相似性之间的中间地位至关重要。

生产更侧重于缩小，静态优化图像以减少字节大小，以及基于路径的捆绑拆分等高级技术，其中我们仅提供用户访问的页面实际使用的模块;树摇动，我们静态分析模块图并删除未使用的函数;关键的CSS内联，我们预先计算最常用的CSS样式，以便我们可以在页面中内联它们，并将其余的样式推迟到一个交互时间更短的异步模型;和安全功能，例如`Content-Security-Policy`，可以缓解XSS或CSRF等攻击媒介。

在涉及应用程序的流程时，测试也起着重要作用。测试通常在两个不同阶段完成。在本地，开发人员在构建之前进行测试，确保连接器不会产生任何错误或测试没有失败。然后，在将代码合并到主线存储库之前，我们经常在持续集成（CI）环境中运行测试，以确保我们不会将损坏的代码合并到我们的应用程序中。当谈到CI时，我们首先构建我们的应用程序，然后对其进行测试，确保编译的应用程序正常。

要使这些过程有效，它们必须保持一致。间歇性测试失败比没有对我们的应用程序的特定部分进行测试感觉更糟糕，因为这些失败会影响每个测试作业。当测试以这种方式失败时，我们再也不能确信传递构建意味着一切都井然有序，这直接转化为整体团队的士气低落和挫折感增加。当发现间歇性测试失败时，最好的行动方案是尽快消除间歇性，或者通过固定间歇源，或者完全取消测试。如果删除了测试，请确保提交票证，以便稍后添加运行良好的测试。测试失败中的间歇性可能是设计不良的症状，在我们寻求修复这些失败的过程中，我们可能会解决架构问题。

正如我们将在模块化JavaScript系列的第四本书中广泛讨论的那样，有许多服务可以帮助CI过程。 Travis [3]通过连接到项目的`git`存储库并运行您选择的命令，提供了一种快速开始集成测试应用程序的方法，其中退出代码为`0`表示CI作业通过，不同的退出代码表示CI工作失败了。 Codecov [4]可以帮助代码覆盖方面，确保我们的应用程序逻辑中的大多数代码路径都被测试用例覆盖。像WebPageTest [5]，PageSpeed [6]和Lighthouse [7]这样的解决方案可以集成到我们在Travis这样的平台上运行的CI流程中，以确保我们的Web应用程序的更改不会对性能产生负面影响。在每次提交甚至Pull Request分支中运行这些挂钩可以帮助将错误和回归保留在应用程序的主线之外，从而避免在暂存和生产环境之外。

请注意到目前为止我们如何关注我们如何构建和测试我们的资产，而不是我们如何部署它们。这两个过程（构建和部署）密切相关，但它们不应该交织在一起。一个明显孤立的构建过程，我们最终得到一个可以轻松部署的打包应用程序，以及一个处理细节的部署过程，无论您是部署到自己的本地环境，还是部署到托管的登台或生产环境，意味着在大多数情况下，我们不需要在构建过程中或运行时担心环境。

### 6.5 无状态性
我们已经探讨了状态如果不加以控制，可以直接导致我们的应用程序死亡。将状态保持在最低限度可直接转换为更易于调试的应用程序。现有的全局状态越少，应用程序的当前条件在任何一个时间点都越不可预测，并且我们在调试时遇到的意外就越少。

一种特别阴险的国家形式是缓存。通过在大多数时间避免昂贵的查找，缓存是提高应用程序性能的好方法。当状态管理工具用作缓存机制时，我们可能陷入陷阱，其中在不同的时间点导出不同的部分派生应用程序状态，从而使用在不同时间点计算的数据呈现应用程序的不同位。

派生状态很少被视为与其派生数据分开的状态。如果不是，我们可能会遇到原始数据更新的情况，但派生状态不会变得陈旧且不准确。相反，当我们总是从原始数据计算派生状态时，我们降低了这个派生状态变得陈旧的可能性。

状态几乎无处不在，实际上是应用程序的同义词，因为没有状态的应用程序并不是特别有用。那么问题出现了：我们如何才能更好地管理国家？如果我们查看典型Web服务器等应用程序，他们的主要工作是接收请求，处理请求并发回适当的响应。因此，Web服务器将状态与每个请求相关联，使其保持在请求处理程序附近，请求处理程序是请求状态的最相关使在Web服务器方面，尽可能少的全局状态，而绝大多数状态包含在每个请求/响应周期中。通过这种方式，当使用多个服务器节点设置水平扩展时，Web服务器可以避免出现问题，这些服务器节点不需要相互通信，以保持Web服务器节点之间的一致性，将该作业留给数据持久层，这最终是国家作为其真相来源的责任。

当请求导致长时间运行的作业（例如发送电子邮件活动，修改持久性数据库中的记录等）时，最好将其交给一个单独的服务 - 再次 - 主要保持关于所述工作的状态。将服务分成特定需求意味着我们可以通过添加更多服务器，持久队列（以便我们不删除作业）等方式使Web服务器保持精简，无状态并改善流程。当通过紧密耦合和状态将每个任务束缚在一起时，随着时间的推移维护，升级和扩展服务可能变得具有挑战性。

在Web服务器的世界中，以缓存形式的派生状态并不罕见。例如，对于可以下载某些书籍的个人网站，我们可能会试图将每本书的PDF表示存储在一个文件中，这样我们就不必在相应`/book`路线时重新编译PDF被访问了。本书更新后，我们将重新计算PDF文件并再次将其刷新到磁盘，以便此派生状态保持新鲜。当我们的Web服务器不再是单节点并且我们开始使用多个节点的集群时，播放关于跨节点更新的书籍的新闻可能并不那么简单，因此最好离开派生状态到持久层。否则，Web服务器节点可能会收到更新书籍，执行更新并重新计算该节点上的PDF文件的请求，但是我们无法使其他节点所服务的PDF文件无效，这将会产生并继续提供PDF表示的陈旧副本。

在这种情况下，更好的替代方案是将派生状态存储在Redis或Amazon S3等数据存储中，我们可以从任何Web服务器更新，然后直接从Redis提供预先计算的结果。通过这种方式，我们仍然可以访问使用预先计算的派生状态的延迟优势，但同时，当这些请求或更新可能发生在多个Web服务器节点上时，我们将保持弹性。

*注意:关于可处置性*

*每当我们连接一个事件监听器时，无论我们是在监听DOM事件还是从事件发送器监听，我们还应该强烈考虑在有关方不再对引发的事件感兴趣时处理监听器。例如，如果我们有一个React组件，在mount时，开始侦听`window`对象上的`resize`事件，我们还应该确保在卸载组件时删除那些事件侦听器。*

*这种勤奋确保我们可以设置和拆除我们的应用程序，而不会留下大量的监听器，这些监听器会导致内存泄漏，这些内存泄漏难以追踪和精确定位。*

*但是，可处置性的概念不仅仅局限于事件处理程序。我们分配并附加到对象，组件或服务的任何类型的资源都应该在该附件不再存在时被释放和清理。这样，我们可以自信地创建和处理尽可能多的组件，而不会使我们的应用程序的性能面临风险。*

可以帮助复杂性管理的另一个改进是构造应用程序，以便所有业务逻辑都包含在单个目录结构（例如`lib/`或`services/`）中，充当我们将所有逻辑保持在一起的物理层。在这样做的过程中，我们将为更多重用逻辑的机会敞开心扉，因为在重新实现对派生状态执行或多或少类似计算的略微不同的函数之前，团队成员将知道在这里查看。

视图组件与其直接对应组件的共置是有吸引力的 - 也就是说，将每个视图的主要组件，子组件，控制器和逻辑保持在相同的结构中 - 但是，以将业务逻辑与特定组件紧密耦合的方式这样做可以是不清楚如何清楚地了解应用程序的整体运作方式。

大型客户端应用程序通常不会缺少应该存储逻辑的单一位置，因此逻辑反而在组件，视图控制器和API之间传播，而不是主要在服务器端处理，并且然后在客户端代码结构中的单个物理位置。这种集中化对于寻求更好地了解应用程序流程的团队的新手来说是关键，因为否则他们必须在我们的视图组件和控制器周围钓鱼以确定正在发生的事情。在第一次在新代码库的未知海岸中浸泡我们的脚趾时，这是一个令人生畏的主张。

关于我们代码的任何其他功能也可以做同样的情况，因为在应用程序中有明确定义的层可以直接理解算法如何从一层到另一层流动，但是当它到来时我们会发现最大的回报。将业务逻辑与其他应用程序代码隔离开来。

使用像Redux或MobX这样的状态管理解决方案，我们将所有状态与应用程序的其余部分隔离开来，这将是另一种选择。无论我们的方法如何，最重要的方面仍然是我们尽可能地将应用程序中的视图呈现方面与业务逻辑方面明确隔离开来。

### 6.6 平等的发展和生产
我们已经确定了明确定义构建和部署过程的重要性。与此类似，我们拥有不同的应用程序环境，如开发，生产，登台，功能分支，SaaS与内部部署环境等。根据定义，环境会有所不同，我们将在不同环境中使用不同的功能，无论是调试工具，产品功能还是性能优化。

每当我们合并特定于环境的功能标志或逻辑时，我们都需要注意这些变化引入的差异。是否可以收紧依赖环境的逻辑，以便引入最小的差异？我们是否应该将新引入的逻辑分支隔离到单个模块中，以尽可能多地处理分歧？在我们为特定环境开发功能时启用的标志是否会导致无意中将错误引入其他启用了不同标志集的环境？

相反，情况恰恰相反。与许多编程一样，创建这些差异相对容易，而删除它们可能是最具挑战性的。这种困难源于我们在开发或单元测试期间通常不会遇到的未知情况，但在我们的生产环境中仍然是有效的情况。

例如，请考虑以下方案。我们有一个使用`Content-Security-Policy`规则的生产应用程序来缓解恶意攻击媒介。对于开发环境，我们还添加了一些额外的规则，例如`'unsafe-inline'`，让我们的开发人员工具操作页面，以便重新加载代码和样式更改，而无需刷新整页，从而加快我们宝贵的开发效率并节省时间。我们的应用程序已经有一个用户可以用来编辑编程源代码的组件，但我们现在需要更改该组件。

我们将当前组件与我们公司自己的组件框架中的新组件进行交换，因此我们知道它经过了实战测试，并且在内部开发的其他生产应用程序中运行良好。我们在本地开发环境中测试一切，一切都按预期工作。测试通过。其他开发人员审查我们的代码，在他们自己的环境中进行本地测试，并发现它没有任何问题。我们合并了我们的代码，几周后部署到生产中。不久之后，我们开始获得关于代码编辑功能被破坏的支持请求，并且需要回滚引入新代码编辑器的变更集。

什么地方出了错？除非找到`style-src：'unsafe-inline'`，否则我们没有注意到新组件不起作用的事实。鉴于我们允许开发中的内联样式，迎合我们方便的开发人员工具，这在我们的团队成员进行的开发或本地测试期间不是问题。但是，当我们部署到生产（遵循更严格的CSP规则集）时，不会提供`unsafe-inline`，并且组件会崩溃。

这里的问题是我们在奇偶校验方面存在分歧，这使我们无法识别新组件中的限制：它使用内联样式来定位文本光标。这与我们严格的CSP规则不一致，但无法正确识别，因为我们的开发环境对于CSP而言比生产环境更为宽松。

尽可能地，我们应该努力将这些差异保持在最低限度，因为如果我们不这样做，错误可能会找到生产方式，客户可能最终会向我们报告错误。仅仅意识到这样的差异是不够的，因为将这些逻辑门保持在你的头脑中是不切实际也不是有效的，这样无论何时实施改变，你都会在心理上经历如果你的代码是变化会如何变化的动作。而是在生产中运行。

适当的集成测试可能会捕获许多这类错误，但情况并非总是如此。

### 6.7 抽象的重要性
急切的抽象可能导致灾难。相反，未能识别和抽象出主要复杂性的来源也可能是非常昂贵的。当我们直接使用复杂的接口，但不一定利用接口必须提供的所有高级配置选项时，我们错过了我们可能正在使用的强大抽象。另一种方法是在复杂界面前创建一个中间层，让消费者通过该层。

这个中间层将负责调用复杂的抽象本身，但是提供了一个更简单的接口，配置选项更少，并且对于对我们来说很重要的用例提高了易用性。通常，复杂或传统的接口要求我们提供可以从传递给函数调用的其他参数派生的数据。例如，我们可能会被问到有多少成年人，有多少孩子，以及总共有多少人想要预订航班，即使后者可以从前者获得。其他示例包括期望字段采用特定的字符串格式（例如可以从本机JavaScript日期派生的日期字符串），使用与实现相关但与消费者无关的命名法，或者缺乏明智的默认值（必需的字段很少更改为默认情况下未设置的建议值以外的任何值）。

当我们构建一个消耗高度参数化API的Web应用程序以搜索最便宜的无障碍航班时 - 举个例子 - 而且我们预计会以几种不同的方式使用这个API，这将花费我们很大的代价抽象出API所要求的大多数参数，这些参数不适合我们的用例。这个中间层可以负责建立合理的默认值，并将合理的数据结构（如本机JavaScript日期或不区分大小写的机场代码）转换为我们正在使用的API所要求的格式。

此外，我们的抽象还可以处理为了水合数据而需要进行的任何后续API调用。例如，航班搜索API可能会为每个不同的航班返回航空公司代码，例如美国航空公司的AA，但是UI消费者还需要将AA水合成航空公司的显示名称，并附带一个徽标以嵌入用户界面，甚至可以快速链接到他们的登记页面。

当我们每次调用支持API时，使用完整的查询，缓解其怪癖和缺点而不是采用抽象方法，不仅难以维护在多个位置使用这些端点的应用程序，而且当我们想要包括来自不同提供商的结果时，这也将成为一种挑战，当然这会有他们自己的一系列怪癖和缺点。此时，我们将有两组独立的API调用，每个供应商一个，每个按摩数据以适应模块中特定于提供者的怪癖，这些怪癖不应该关注这些问题，而只关注结果本身。

中间层可以利用来自消费者的规范化查询，例如我们采用本机日期然后在调用航班搜索API时对其进行格式化，然后将该查询调整为实际产生航班搜索结果的任一后备服务。这样，消费者只需要处理单个简化的界面，同时具有与提供不同接口的两个类似支持服务无缝交互的能力。

对于从这些后备服务中的任何一个返回的数据结构，可以并且应该进行相同的情况。通过将数据标准化为仅包含与我们的消费者相关的信息的结构，并使用他们所需的衍生信息（例如前面解释的航空公司名称和详细信息）来增加数据，消费者可以在利用他们的同时关注他们自己的关注点。数据结构接近他们的需求。同时，这种规范化使我们的抽象能够合并来自两个支持服务的结果，并将它们视为来自单一来源：抽象本身，将支持服务留作仅仅是实现细节。

当我们直接依赖原始响应时，我们可能会发现自己编写的视图组件比它们需要的更冗长，包含逻辑来汇集渲染视图所需的不同元数据元素，将数据从API表示映射到我们的实际上想要显示，然后将用户输入映射回API期望的内容。通过介于两者之间的层，我们可以将这个映射逻辑保存在一个地方，并使我们的应用程序的其余部分不受其影响。

掌握模块化JavaScript并不是严格遵循一套定义明确的规则，而是能够让自己置身于消费者的角度，预先计划可能正在进行的功能开发，但不是太广泛 - 并且您应该将相同的尊重和谨慎放在界面设计中来处理文档。作为实现细节的内部结构总是可以在以后进行改进。当然，我们想要修补 - 或者至少是抽象地 - 消除那些复杂性的来源，但是在它们的外壳中，美丽的模块才能真正发挥作用。最重要的是，相信自己的判断，不要让最新的发展时尚阻碍你的决策！
***
1. 您可以在以下网址找到原始的12 Factor App方法及其文档：https：//mjavascript.com/out/12factor。
2. 当我们运行`npm install`时，npm也会在`npm install`结束后执行`rebuild`步骤。 重建步骤重新编译本机二进制文件，根据执行环境和本地计算机的操作系统构建不同的资产。
3. 访问他们的网站：https：//mjavascript.com/out/travis
4. 访问他们的网站：https：//mjavascript.com/out/codecov
5. 访问他们的网站：https：//mjavascript.com/out/wpt
6. 访问他们的网站：https：//mjavascript.com/out/pagespeed
7. 访问他们的网站：https：//mjavascript.com/out/lighthouse